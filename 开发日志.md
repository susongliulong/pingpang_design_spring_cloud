# 2024/3/24

开发进行到现在完成的主要工作有前后端开发环境的搭建，包含

1. 后端开发环境搭建：导入各种各样的依赖，配置常用的消息转化器，处理跨域和Cookie统一拦截
2. 前端开发环境搭建：使用Vue3
3. 使用git作为版本控制工具



完善前端多个界面的原型设计：

1. 注册和登录界面以及新闻展示界面和教程展示界面
2. 完成重要组件设计：评论框（CommentVue）

完成数据库设计:

1. 使用Power Designer完成数据库设计

后端代码自动生成：

1. 使用mbg自动生成相应的模板类

# 2024/3/29

概要设计阶段所有的工作已经完成，前期进行了大量的预编码工作。接下来结合前期编码以及自身实力对项目进行编写。最终完成整个项目的代码编写。但是在论文撰写中遇到了困难，究竟是先写文档还是先实现？

# 2024/4/7

[springcloud 整合redis_redis_污青-华为云开发者联盟 (csdn.net)](https://huaweicloud.csdn.net/63356736d3efff3090b55c64.html?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-5-122043178-blog-124349947.235^v43^pc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~activity-5-122043178-blog-124349947.235^v43^pc_blog_bottom_relevance_base7&utm_relevant_index=10#devmenu6)

上面的这篇文章涉及到Redis的基础使用，直接复制粘贴即可使用。很快。

完成账号管理模块的设计，实现以及测试工作。主要实现的亮点有：

1. 用户登录失败次数超过三次的时候暂停用户登录1分钟
2. 图片上传和下载

在实现过程中遇到了各种各样的问题，现在对各种问题进行总结

## maven依赖冲突问题

首先需要注意的是每一个Spring Cloud都对因一个Spring Boot版本。这是最基本的版本匹配。

其次需要注意的是Spring Cloud基于Spring Boot，使用到了Spring Boot中一些核心依赖，例如web，test。其他组件整合进入Spring Boot时通常采用\*\***-starter的方式或者spring-boot-starter-\*\*的方式，不要直接导入某个具体的依赖。

不同的组件对Spring Boot的要求不同，例如Spring Boot3中Mybatis Plus的版本和Spring Boot2中的就不一样，如果错误的配置。在启动的时候就会出现某个jar包中不存在指定的类的错误。

## 前端单选框和多选框数据回显问题

无论是单选框radio还是多选框checkBox，都是通过标签中的value属性来控制回显的。需要特别注意value属性的类型。当写成string类型的时候，此时需要特别注意数据回显时v-model绑定的值也为string类型，同理也适用于number类型。代码示例如下：

```vue
<el-form-item label="球龄" prop="playYears">
              <el-radio-group v-model="ruleForm.playYears">
                <el-radio label="1月" :value="1" />
                <el-radio label="3月" :value="3" />
                <el-radio label="1年" :value="12" />
                <el-radio label="5年" :value="60"/>
                <el-radio label="10年" :value="120" />
              </el-radio-group>
</el-form-item>
```

此时playYears应当为number类型，后端传给前端用来数据回显的时候playYears也应当为number类型，而不要错误写成string类型。如下：

```vue
<el-form-item label="球龄" prop="playYears">
              <el-radio-group v-model="ruleForm.playYears">
                <el-radio label="1月" value="1" />
                <el-radio label="3月" value="3" />
                <el-radio label="1年" value="12" />
                <el-radio label="5年" value="60"/>
                <el-radio label="10年" value="120" />
              </el-radio-group>
            </el-form-item>
```

## 使用openfeign进行服务调用

1. 服务调用的时候尽量不要传递HttpServletRequest或者HttpServletResponse参数
2. 服务调用的时候，需要显式的用@RequestParam注明参数的名称，在不写的情况下，方法默认在参数前面加的注解是@RequestBody

## 使用DTO封装前端数据请求，使用Vo返回后台处理数据

## 使用axios出现的异步问题

当同步代码和异步代码同时出现的时候，此时需要注意代码执行的顺序。一种解决方案是对于异步方法，设置参数。由同步代码对参数传值。或者使用if-else语句进行显示控制。

# 2024/4/16

## 完成资讯管理代码编写

1. idea实现热部署

## 生成资讯管理所需要的测试数据

1. 使用Java作为爬虫，所用到的核心API包含Java正则表达式，以及HttpConnection请求客户端
2. Java正则表达式的语法需要熟悉

# 2024/4/19 赛事管理

1. 生成赛事管理所需要的测试数据
2. 获取发布的赛事信息
3. 根据关键词搜索赛事信息
4. 赛事发布
5. 赛事报名
6. 赛事分组

## 爬取https网站的时候需要安装对应网站的证书

证书格式为crt

下载完毕之后，使用keytools工具安装证书

```java
keytool -import -alias <证书别名> -keystore cacerts -file <证书位置>

keytool -list -keystore cacerts -alias <证书别名>
```

在使用第三方代码访问时，将不会报错：

> unable to find valid certification path to requested target

第三方访问代码：

```java
URL url = new URL("https://www.gdut.edu.cn/jgsz/jxjg.htm");
HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();
urlConnection.setRequestMethod("GET");
BufferedReader bufferedReader = new BufferedReader(newInputStreamReader(urlConnection.getInputStream()));
String line;
String collegePattern="target=\"_blank\">(.{2,13})学院</a>";
Pattern pattern = Pattern.compile(collegePattern);
while((line = bufferedReader.readLine())!=null){
     Matcher matcher = pattern.matcher(line);
     while(matcher.find()){
                
     }
}
```

赛事信息的展示界面主要参考“华为云”赛事信息界面。使用Element Plus中的table组件加以实现。在展示的时候，仅展示赛事的简要信息。后端创建MatchController来处理和赛事相关的请求。首先创建overviewMatch方法，该方法接收的参数有查找关键词keyWord、比赛级别level、最低积分要求minPonint以及比赛开始时间startTime和报名截止时间endTime。其中这些参数可以为空，为空的时候返回比赛开始时间和报名截止时间距离当前时间最近的10场比赛返回给前端。不为空的时候，根据方法接收到的参数进行查询。

用户可以查看比赛的详细信息，对于详细信息的展示。创建MatchMessageController处理该请求。创建方法message进行处理，方法接收的参数为比赛id。首先查找Redis缓存查看是否在缓存中，如果不在的话存入键<id>，值为赛事信息的详细内容，最后将详细内容返回给前端。

用户查看赛事详细信息之后，选择报名。首先对用户积分进行校验。校验通过的情况下才允许用户报名。前端使用ElMessageBox弹出处理框。等待用户确定联系方式之后提交给后端。后端在MatchController中创建方法signUp，接收的参数为用户id和赛事id。更新表match和user_match之后，如果参赛选手人数达到报名限制或者到达比赛截止时间，此时需要对选手进行分组。调用分组方法partition。改方法接收的参数有参赛选手能力信息数组userAbilities，元素类型为单独封装的一个类UserAbility；返回的结果类型为HashMap类型，其中键的类型为小组编号，从1开始计数。值的类型为List<UserAbility>。首先利用Collection是提供的shuffle方法随机打乱userAbilities数组，在此基础上。然后再调用subList方法获取每个小组的参赛选手信息。最后还需要对每个小组进行如下的验证：对于每一个小组的成员，按照发球能力由高到低，接发球能力由高到低，进攻能力由高到低以及防守能力由高到低进行排序，计算排名最高者和排名最低者在上述能力的差值，得到发球能力差值                                、接发球能力差值  、进攻能力差值  和防守能力差值  。最后计算加权平均值：

  

如果该值大于3，则需要重新分配。重新分配在那些不满足该条件的小组中进行。交换选手使得上面的  的值小于等于3 。